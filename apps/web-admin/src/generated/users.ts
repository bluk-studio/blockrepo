// @generated by protobuf-ts 2.3.0
// @generated from protobuf file "users.proto" (package "bluk_games", syntax proto3)
// tslint:disable
import { AuthorizeAuthTokenRequest } from "./types/metadata/UsersService";
import { WatchAuthTokenRequest } from "./types/metadata/UsersService";
import { AuthToken } from "./types/token";
import { EmptyRequest } from "./types/miscellaneous";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Permission } from "./types/permissions";
import { TokenType } from "./types/token";
import { Token } from "./types/token";
import { User } from "./types/user";
/**
 * Requests/Responses
 *
 * @generated from protobuf message bluk_games.FindOneUserRequest
 */
export interface FindOneUserRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message bluk_games.FetchMeRequest
 */
export interface FetchMeRequest {
}
/**
 * @generated from protobuf message bluk_games.FetchMeResponse
 */
export interface FetchMeResponse {
    /**
     * @generated from protobuf field: User user = 1;
     */
    user?: User;
    /**
     * @generated from protobuf field: Token token = 2;
     */
    token?: Token;
}
/**
 * @generated from protobuf message bluk_games.GenerateTokenRequest
 */
export interface GenerateTokenRequest {
    /**
     * @generated from protobuf field: TokenType type = 1;
     */
    type: TokenType;
    /**
     * @generated from protobuf field: string entityId = 2;
     */
    entityId: string;
    /**
     * @generated from protobuf field: repeated Permission permissions = 3;
     */
    permissions: Permission[];
}
/**
 * @generated from protobuf message bluk_games.FetchTokenRequest
 */
export interface FetchTokenRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class FindOneUserRequest$Type extends MessageType<FindOneUserRequest> {
    constructor() {
        super("bluk_games.FindOneUserRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FindOneUserRequest>): FindOneUserRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FindOneUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindOneUserRequest): FindOneUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindOneUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bluk_games.FindOneUserRequest
 */
export const FindOneUserRequest = new FindOneUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchMeRequest$Type extends MessageType<FetchMeRequest> {
    constructor() {
        super("bluk_games.FetchMeRequest", []);
    }
    create(value?: PartialMessage<FetchMeRequest>): FetchMeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchMeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchMeRequest): FetchMeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FetchMeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bluk_games.FetchMeRequest
 */
export const FetchMeRequest = new FetchMeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchMeResponse$Type extends MessageType<FetchMeResponse> {
    constructor() {
        super("bluk_games.FetchMeResponse", [
            { no: 1, name: "user", kind: "message", T: () => User },
            { no: 2, name: "token", kind: "message", T: () => Token }
        ]);
    }
    create(value?: PartialMessage<FetchMeResponse>): FetchMeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchMeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchMeResponse): FetchMeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* Token token */ 2:
                    message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchMeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Token token = 2; */
        if (message.token)
            Token.internalBinaryWrite(message.token, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bluk_games.FetchMeResponse
 */
export const FetchMeResponse = new FetchMeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateTokenRequest$Type extends MessageType<GenerateTokenRequest> {
    constructor() {
        super("bluk_games.GenerateTokenRequest", [
            { no: 1, name: "type", kind: "enum", T: () => ["TokenType", TokenType] },
            { no: 2, name: "entityId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "permissions", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["Permission", Permission] }
        ]);
    }
    create(value?: PartialMessage<GenerateTokenRequest>): GenerateTokenRequest {
        const message = { type: 0, entityId: "", permissions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateTokenRequest): GenerateTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TokenType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string entityId */ 2:
                    message.entityId = reader.string();
                    break;
                case /* repeated Permission permissions */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.permissions.push(reader.int32());
                    else
                        message.permissions.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* TokenType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string entityId = 2; */
        if (message.entityId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityId);
        /* repeated Permission permissions = 3; */
        if (message.permissions.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.permissions.length; i++)
                writer.int32(message.permissions[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bluk_games.GenerateTokenRequest
 */
export const GenerateTokenRequest = new GenerateTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchTokenRequest$Type extends MessageType<FetchTokenRequest> {
    constructor() {
        super("bluk_games.FetchTokenRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FetchTokenRequest>): FetchTokenRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchTokenRequest): FetchTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bluk_games.FetchTokenRequest
 */
export const FetchTokenRequest = new FetchTokenRequest$Type();
/**
 * @generated ServiceType for protobuf service bluk_games.UserService
 */
export const UserService = new ServiceType("bluk_games.UserService", [
    { name: "FindOne", options: {}, I: FindOneUserRequest, O: User },
    { name: "FetchMe", options: {}, I: FetchMeRequest, O: FetchMeResponse },
    { name: "CreateAuthToken", options: {}, I: EmptyRequest, O: AuthToken },
    { name: "WatchAuthToken", serverStreaming: true, options: {}, I: WatchAuthTokenRequest, O: AuthToken },
    { name: "AuthorizeAuthToken", options: {}, I: AuthorizeAuthTokenRequest, O: AuthToken }
]);
/**
 * @generated ServiceType for protobuf service bluk_games.TokenService
 */
export const TokenService = new ServiceType("bluk_games.TokenService", [
    { name: "GenerateToken", options: {}, I: GenerateTokenRequest, O: Token },
    { name: "FetchToken", options: {}, I: FetchTokenRequest, O: Token }
]);
